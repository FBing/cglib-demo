# Java基础
## 面向对象的三个特征
封装,继承,多态

## 多态的好处
允许不同类对象对同一消息做出响应,即同一消息可以根据发送对象的不同而采用多种不同的行为方式(发送消息就是函数调用).主要有以下优点:

* 可替换性: 多态对已存在代码具有可替换性.
* 可扩充性: 增加新的子类不影响已经存在的类结构.
* 接口性: 多态是超累通过方法签名,想子类提供一个公共接口,由子类来完善或者重写它来实现的.
* 灵活性:

## 代码中如何实现多态

实现多态主要有以下三种方式:
1. 接口实现
2. 继承父类重写方法
3. 同一类中进行方法重载

## 虚拟机是如何实现多态的

动态绑定技术(dynamic binding),执行期间判断所引用对象的实际类型,根据实际类型调用对应的方法.

## 接口的意义

接口的意义用三个词就可以概括:规范,扩展,回调.

## 抽象类的意义

抽象类的意义可以用三句话来概括:

* 为其他子类提供一个公共的类型
* 封装子类中重复定义的内容
* 定义抽象方法,子类虽然有不同的实现,但是定义时一致的

## 接口和抽象类的区别

|比较	|抽象类 |	接口|
|---|---|---|
|默认方法	|抽象类可以有默认的方法实现	|java 8之前,接口中不存在方法的实现.|
|实现方式	|子类使用extends关键字来继承抽象类.如果子类不是抽象类,子类需要提供抽象类中所声明方法的实现.	|子类使用implements来实现接口,需要提供接口中所有声明的实现.|
|构造器	|抽象类中可以有构造器	|接口中不能|
|和正常类区别	|抽象类不能被实例化	|接口则是完全不同的类型|
|访问修饰符	|抽象方法可以有public,protected和default等修饰|	|接口默认是public,不能使用其他修饰符|
|多继承	|一个子类只能存在一个父类|	一个子类可以实现多个接口|
|添加新方法	|想抽象类中添加新方法,可以提供默认的实现,因此可以不修改子类现有的代码|	|如果往接口中添加新方法,则子类中需要实现该方法.|

## java当中的四种引用
强引用,软引用,弱引用,虚引用.不同的引用类型主要体现在GC上:

* 强引用：如果一个对象具有强引用，它就不会被垃圾回收器回收。即使当前内存空间不足，JVM也不会回收它，而是抛出 OutOfMemoryError 错误，使程序异常终止。如果想中断强引用和某个对象之间的关联，可以显式地将引用赋值为null，这样一来的话，JVM在合适的时间就会回收该对象
* 软引用：在使用软引用时，如果内存的空间足够，软引用就能继续被使用，而不会被垃圾回收器回收，只有在内存不足时，软引用才会被垃圾回收器回收。
* 弱引用：具有弱引用的对象拥有的生命周期更短暂。因为当 JVM 进行垃圾回收，一旦发现弱引用对象，无论当前内存空间是否充足，都会将弱引用回收。不过由于垃圾回收器是一个优先级较低的线程，所以并不一定能迅速发现弱引用对象
* 虚引用：顾名思义，就是形同虚设，如果一个对象仅持有虚引用，那么它相当于没有引用，在任何时候都可能被垃圾回收器回收。

## WeakReference与SoftReference的区别?

这点在四种引用类型中已经做了解释,这里简单说明一下即可:
虽然 WeakReference 与 SoftReference 都有利于提高 GC 和 内存的效率，但是 WeakReference ，一旦失去最后一个强引用，就会被 GC 回收，而软引用虽然不能阻止被回收，但是可以延迟到 JVM 内存不足的时候。

## 为什么要有不同的引用类型

不像C语言,我们可以控制内存的申请和释放,在Java中有时候我们需要适当的控制对象被回收的时机,因此就诞生了不同的引用类型,可以说不同的引用类型实则是对GC回收时机不可控的妥协.有以下几个使用场景可以充分的说明:

利用软引用和弱引用解决OOM问题：用一个HashMap来保存图片的路径和相应图片对象关联的软引用之间的映射关系，在内存不足时，JVM会自动回收这些缓存图片对象所占用的空间，从而有效地避免了OOM的问题.
通过软引用实现Java对象的高速缓存:比如我们创建了一Person的类，如果每次需要查询一个人的信息,哪怕是几秒中之前刚刚查询过的，都要重新构建一个实例，这将引起大量Person对象的消耗,并且由于这些对象的生命周期相对较短,会引起多次GC影响性能。此时,通过软引用和 HashMap 的结合可以构建高速缓存,提供性能.

## java中==和eqauls()的区别,equals()和hashcode的区别

==是运算符,用于比较两个变量是否相等,而equals是Object类的方法,用于比较两个对象是否相等.
默认Object类的equals方法是比较两个对象的地址,此时和==的结果一样.
换句话说:基本类型比较用==,比较的是他们的值.
默认下,对象用==比较时,比较的是内存地址,如果需要比较对象内容,需要重写equal方法

## equals()和hashcode()的联系

hashCode()是Object类的一个方法,返回一个哈希值.如果两个对象根据equal()方法比较相等,那么调用这两个对象中任意一个对象的hashCode()方法必须产生相同的哈希值.
如果两个对象根据eqaul()方法比较不相等,那么产生的哈希值不一定相等(碰撞的情况下还是会相等的.)

## hashCode()有什么用?与a.equals(b)有什么关系

hashCode() 方法是相应对象整型的 hash 值。它常用于基于 hash 的集合类，如 Hashtable、HashMap、LinkedHashMap等等。它与 equals() 方法关系特别紧密。根据 Java 规范，两个使用 equal() 方法来判断相等的对象，必须具有相同的 hashcode。

将对象放入到集合中时,首先判断要放入对象的hashcode是否已经在集合中存在,不存在则直接放入集合.如果hashcode相等,然后通过equal()方法判断要放入对象与集合中的任意对象是否相等:如果equal()判断不相等,直接将该元素放入集合中,否则不放入.

## 3*0.1==0.3返回值是什么

false，因为有些浮点数不能完全精确的表示出来。

## a=a+b与a+=b有什么区别吗?

隐式的将加操作的结果类型强制转换为持有结果的类型。如果两这个整型相加，如 byte、short 或者 int，首先会将它们提升到 int 类型，然后在执行加法操作。如果加法操作的结果比 a 的最大值要大，则 a+b 会出现编译错误，但是 a += b 没问题，如下：
byte a = 127;
byte b = 127;
b = a + b; // error : cannot convert from int to byte
b += a; // ok
（译者注：这个地方应该表述的有误，其实无论 a+b 的值为多少，编译器都会报错，因为 a+b 操作会将 a、b 提升为 int 类型，所以将 int 类型赋值给 byte 就会编译出错）

## 深拷贝和浅拷贝的区别是什么?

浅拷贝：被复制对象的所有变量都含有与原来的对象相同的值，而所有的对其他对象的引用仍然指向原来的对象。换言之，浅拷贝仅仅复制所考虑的对象，而不复制它所引用的对象。

深拷贝：被复制对象的所有变量都含有与原来的对象相同的值，而那些引用其他对象的变量将指向被复制过的新对象，而不再是原有的那些被引用的对象。换言之，深拷贝把要复制的对象所引用的对象都复制了一遍。

## java中int char,long各占多少字节?

|类型|	字节数|
|---|---|
|short|	2|
|char	|2|
|int|	4|
|long|	8|
|float	|4|
|double	|8|


## java int和Integer的区别

Integer是int的包装类型,在拆箱和装箱中,而知自动转换.int是基本类型，直接存数值，而integer是对象，用一个引用指向这个对象.

## String,StringBuffer和StringBuilder区别

String是字符串常量,final修饰;
StringBuffer字符串变量(线程安全);
StringBuilder 字符串变量(线程不安全).

## java当中使用什么类型表示价格比较好?

如果不是特别关心内存和性能的话，使用BigDecimal，否则使用预定义精度的 double 类型。

## 如何将byte转为String

可以使用 String 接收 byte[] 参数的构造器来进行转换，需要注意的点是要使用的正确的编码，否则会使用平台默认编码，这个编码可能跟原来的编码相同，也可能不同。

## 关于异常

### 简单描述java异常体系

Java当中定义了许多异常类，并且定义了基类java.lang.Throwable作为所有异常的超类。Java语言设计者将异常划分为两类：Error和Exception，其体系结构大致如下图所示：

Throwable：有两个重要的子类：Exception（异常）和Error（错误），两者都包含了大量的异常处理类。
1. Error（错误）：是程序中无法处理的错误，表示运行应用程序中出现了严重的错误。此类错误一般表示代码运行时JVM出现问题。通常有Virtual MachineError（虚拟机运行错误）、NoClassDefFoundError（类定义错误）等。比如说当jvm耗完可用内存时，将出现OutOfMemoryError。此类错误发生时，JVM将终止线程。
这些错误是不可查的，非代码性错误。因此，当此类错误发生时，应用不应该去处理此类错误。
2. Exception（异常）：程序本身可以捕获并且可以处理的异常。


Exception这种异常又分为两类：运行时异常和编译异常。
1. 运行时异常(不受检异常)：RuntimeException类极其子类表示JVM在运行期间可能出现的错误。比如说试图使用空值对象的引用（NullPointerException）、数组下标越界（ArrayIndexOutBoundException）。此类异常属于不可查异常，一般是由程序逻辑错误引起的，在程序中可以选择捕获处理，也可以不处理。
2. 编译异常(受检异常)：Exception中除RuntimeException极其子类之外的异常。如果程序中出现此类异常，比如说IOException，必须对该异常进行处理，否则编译不通过。在程序中，通常不会自定义该类异常，而是直接使用系统提供的异常类。

可查异常与不可查异常：java的所有异常可以分为可查异常（checked exception）和不可查异常（unchecked exception）。
1、可查异常：编译器要求必须处理的异常。正确的程序在运行过程中，经常容易出现的、符合预期的异常情况。一旦发生此类异常，就必须采用某种方式进行处理。除RuntimeException及其子类外，其他的Exception异常都属于可查异常。编译器会检查此类异常，也就是说当编译器检查到应用中的某处可能会此类异常时，将会提示你处理本异常——要么使用try-catch捕获，要么使用throws语句抛出，否则编译不通过。
2、不可查异常：编译器不会进行检查并且不要求必须处理的异常，也就说当程序中出现此类异常时，即使我们没有try-catch捕获它，也没有使用throws抛出该异常，编译也会正常通过。该类异常包括运行时异常（RuntimeException极其子类）和错误（Error）。

### 什么是异常链

详情直接参见白话异常机制,不做解释了.


## 关于日期

### SimpleDateFormat是线程安全的吗?

非常不幸，DateFormat 的所有实现，包括 SimpleDateFormat 都不是线程安全的，因此你不应该在多线程序中使用，除非是在对外线程安全的环境中使用，如 将 SimpleDateFormat 限制在 ThreadLocal 中。
如果你不这么做，在解析或者格式化日期的时候，可能会获取到一个不正确的结果。因此，从日期、时间处理的所有实践来说，我强力推荐 joda-time 库。

### 如何格式化日期?

Java 中，可以使用 SimpleDateFormat 类或者 joda-time 库来格式日期。DateFormat 类允许你使用多种流行的格式来格式化日期。
参见答案中的示例代码，代码中演示了将日期格式化成不同的格式，如 dd-MM-yyyy 或 ddMMyyyy。


## 关于序列化

### Java Serializable 与 Externalizable 的区别

Serializable 接口是一个序列化 Java 类的接口，以便于它们可以在网络上传输或者可以将它们的状态保存在磁盘上，是 JVM 内嵌的默认序列化方式，成本高、脆弱而且不安全。
Externalizable 允许你控制整个序列化过程，指定特定的二进制格式，增加安全机制。