# 排序算法
排序算法是最基本最常用的算法，不同的排序算法在不同的场景或应用中会有不同的表现，我们需要对各种排序算法熟练才能将它们应用到实际当中，才能更好地发挥它们的优势。今天，来总结下各种排序算法。

下面这个表格总结了各种排序算法的复杂度与稳定性：
| 排序算法 | 平均时间复杂度 | 最坏时间复杂度 | 空间复杂度 |稳定性 |
| --- | --- | --- | --- | --- |
| 冒泡排序 | O(n2) | O(n2) | O(1) | 稳定 |
| 选择排序 | O(n2) | O(n2) | O(1) | 不稳定 |
| 直接插入排序 | O(n2) | O(n2) | O(1) | 稳定 |
| 快速排序 | O(nlogn) | O(n2) | O(1) | 不稳定 |
| 归并排序 | O(nlogn) | O(nlogn) | O(1) | 稳定 |
| 堆排序 | O(nlogn) | O(nlogn) | O(1) | 不稳定 |
| 希尔排序 | O(nlogn) | O(n2) | O(1) | 不稳定 |
| 基数排序 | O(n2) | O(n2) | O(1) | 稳定 |


## 冒泡排序

冒泡排序可谓是最经典的排序算法了，它是基于比较的排序算法，时间复杂度为O(n^2)，其优点是实现简单，n较小时性能较好。

### 原理
算法步骤：
1. 比较相邻的元素。如果第一个比第二个大，就交换他们两个。
2. 对第0个到第n-1个数据做同样的工作。这时，最大的数就“浮”到了数组最后的位置上。
3. 针对所有的元素重复以上的步骤，除了最后一个。
4. 持续每次对越来越少的元素重复上面的步骤，直到没有任何一对数字需要比较。

### 代码实现(Java)
```
    public void bubble_sort(int[] arr){

		for(int i=0;i<arr.length;i++){

			for(int j=i+1;j<arr.length;j++){

				if(arr[i]>arr[j]){
					swap(arr, i, j);
				}
			}
		}
	}

```

其中，swap方法如下:
```
    protected void swap(int[] arr, int i, int j){
		int temp = arr[i];
		arr[i] = arr[j];
		arr[j]= temp;
	}
```

## 选择排序

选择排序无疑是最简单直观的排序。

### 原理
算法步骤：
1. 在未排序序列中找到最小（大）元素，存放到排序序列的起始位置。
2. 再从剩余未排序元素中继续寻找最小（大）元素，然后放到已排序序列的末尾。
3. 以此类推，直到所有元素均排序完毕。

### 代码实现(Java)
```
    public void select_sort(int[] arr) {

		int len = arr.length;
		for (int i = 0; i < len; i++) {
			int index = i;
			for (int j = i + 1; j < len; j++) {
				if (arr[j] < arr[index])
					index = j;
			}
			if (index != i) {
				swap(arr, i, index);
			}
		}
	}
```

## 插入排序
插入排序的工作原理是，对于每个未排序数据，在已排序序列中从后向前扫描，找到相应位置并插入。

### 原理
算法步骤：
1. 从第一个元素开始，该元素可以认为已经被排序
2. 取出下一个元素，在已经排序的元素序列中从后向前扫描
3. 如果被扫描的元素（已排序）大于新元素，将该元素后移一位
4. 重复步骤3，直到找到已排序的元素小于或者等于新元素的位置
5. 将新元素插入到该位置后
6. 重复步骤2~5

### 代码实现(Java)
```
    public void insert_sort(int arr[]) {
        int len = arr.length;
        for (int i = 1; i < len; i ++) {
            int j = i - 1;
            int k = arr[i];
            while (j > -1 && k < arr[j] ) {
                arr[j + 1] = arr[j];
                j --;
            }
            arr[j + 1] = k;
        }
    }
```

## 希尔排序
希尔排序，也称递减增量排序算法，实质是分组插入排序。由 Donald Shell 于1959年提出。希尔排序是非稳定排序算法。

希尔排序的基本思想是：
> 将数组列在一个表中并对列分别进行插入排序，重复这过程，不过每次用更长的列（步长更长了，列数更少了）来进行。
> 最后整个表就只有一列了。将数组转换至表是为了更好地理解这算法，算法本身还是使用数组进行排序。

### 代码实现(Java)
```

```

## 快速排序
快速排序通常明显比同为Ο(n log n)的其他算法更快，因此常被采用，而且快排采用了分治法的思想，所以在很多笔试面试中能经常看到快排的影子。可见掌握快排的重要性。

### 原理
算法步骤：

1. 从数列中挑出一个元素作为基准数。
2. 分区过程，将比基准数大的放到右边，小于或等于它的数都放到左边。
3. 再对左右区间递归执行第二步，直至各区间只有一个数。

### 代码实现(Java)
```
	public void quick_sort(int arr[], int left, int right) {
		if (left < right) {
			int i = left, j = right, target = arr[left];
			while (i < j) {
				while (i < j && arr[j] > target)
					j--;
				if (i < j)
					arr[i++] = arr[j];

				while (i < j && arr[i] < target)
					i++;
				if (i < j)
					arr[j] = arr[i];
			}
			arr[i] = target;
			quick_sort(arr, left, i - 1);
			quick_sort(arr, i + 1, right);
		}
	}
```

## 归并排序
归并排序是采用分治法的一个非常典型的应用。归并排序的思想就是先递归分解数组，再合并数组。


### 代码实现(Java)
```

```

## 堆排序
堆排序在 top K 问题中使用比较频繁。堆排序是采用二叉堆的数据结构来实现的，虽然实质上还是一维数组。
二叉堆是一个近似完全二叉树 。


### 二叉堆具有以下性质：

* 父节点的键值总是大于或等于（小于或等于）任何一个子节点的键值。
* 每个节点的左右子树都是一个二叉堆（都是最大堆或最小堆）。


### 代码实现(Java)
```

```